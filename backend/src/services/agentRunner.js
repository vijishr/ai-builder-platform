import fs from 'fs/promises'
import fsSync from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const dataDir = path.join(__dirname, '..', '..', 'data', 'agent_runs')
if (!fsSync.existsSync(dataDir)) fsSync.mkdirSync(dataDir, { recursive: true })

export async function runAgent(agentId, options = {}) {
  const runId = Date.now().toString()
  const runDir = path.join(dataDir, agentId)
  if (!fsSync.existsSync(runDir)) fsSync.mkdirSync(runDir, { recursive: true })
  const runPath = path.join(runDir, `${runId}.json`)

  const log = []
  const start = new Date().toISOString()
  log.push(`[${start}] Starting agent run ${runId} for agent ${agentId}`)

  try {
    // Step 1: Generate code (simulated)
    log.push(`[${new Date().toISOString()}] Generating code...`)
    const generated = generateCodeStub(agentId, options)

    // Write generated files to run folder
    const outputDir = path.join(runDir, runId)
    if (!fsSync.existsSync(outputDir)) fsSync.mkdirSync(outputDir, { recursive: true })
    await fs.writeFile(path.join(outputDir, 'generated.js'), generated.frontend.javascript, 'utf8')
    await fs.writeFile(path.join(outputDir, 'generated.html'), generated.frontend.html, 'utf8')
    await fs.writeFile(path.join(outputDir, 'generated.css'), generated.frontend.css, 'utf8')
    log.push(`[${new Date().toISOString()}] Generated files written to ${outputDir}`)

    // Step 2: Simulate tests
    log.push(`[${new Date().toISOString()}] Running automated tests (simulated)...`)
    const testResult = simulateTests(generated)
    log.push(`[${new Date().toISOString()}] Tests ${testResult.passed ? 'PASSED' : 'FAILED'} - ${testResult.summary}`)

    // Step 3: Save run metadata
    const runMeta = {
      id: runId,
      agentId,
      startedAt: start,
      finishedAt: new Date().toISOString(),
      status: testResult.passed ? 'completed' : 'failed',
      logs: log,
      outputDir: outputDir,
      testResult
    }
    await fs.writeFile(runPath, JSON.stringify(runMeta, null, 2), 'utf8')

    return runMeta
  } catch (e) {
    const errMeta = {
      id: runId,
      agentId,
      startedAt: start,
      finishedAt: new Date().toISOString(),
      status: 'error',
      error: e.message,
      logs: log
    }
    await fs.writeFile(runPath, JSON.stringify(errMeta, null, 2), 'utf8')
    throw e
  }
}

function generateCodeStub(agentId, options = {}) {
  // Simple stubbed generated code
  const html = `<!doctype html>\n<html>\n<head>\n  <meta charset="utf-8">\n  <title>AutoGen - ${agentId}</title>\n  <link rel="stylesheet" href="generated.css">\n</head>\n<body>\n  <div id="app">\n    <h1>Auto-generated by Agent ${agentId}</h1>\n    <p>${options.prompt || 'A generated page'}</p>\n  </div>\n  <script src="generated.js"></script>\n</body>\n</html>`

  const css = `body { font-family: Arial, sans-serif; padding: 2rem; background:#f8fafc; } h1{ color:#0f172a }`;

  const javascript = `console.log('Auto-generated script for agent ${agentId}');\ndocument.getElementById('app').dataset.agent='${agentId}';`;

  return {
    frontend: { html, css, javascript }
  }
}

function simulateTests(generated) {
  // Very naive test simulation: ensure generated files contain expected markers
  const hasHtml = typeof generated.frontend.html === 'string' && generated.frontend.html.includes('<html')
  const hasJs = typeof generated.frontend.javascript === 'string' && generated.frontend.javascript.includes('Auto-generated')
  const passed = hasHtml && hasJs
  return {
    passed,
    summary: passed ? 'All basic checks passed' : 'Missing expected content in generated output',
    details: { hasHtml, hasJs }
  }
}

export async function getRun(agentId, runId) {
  const runPath = path.join(dataDir, agentId, `${runId}.json`)
  try {
    const raw = await fs.readFile(runPath, 'utf8')
    return JSON.parse(raw)
  } catch (e) {
    return null
  }
}

export async function listRuns(agentId) {
  const runDir = path.join(dataDir, agentId)
  if (!fsSync.existsSync(runDir)) return []
  const files = await fs.readdir(runDir)
  return files.filter(f => f.endsWith('.json')).map(f => f.replace('.json',''))
}

// Stream live run logs (for SSE)
export async function streamRunLogs(agentId, runId, callback) {
  const runPath = path.join(dataDir, agentId, `${runId}.json`)
  let lastSize = 0

  const streamInterval = setInterval(async () => {
    try {
      if (fsSync.existsSync(runPath)) {
        const raw = await fs.readFile(runPath, 'utf8')
        const data = JSON.parse(raw)
        
        // Send new logs since last check
        if (data.logs && data.logs.length > lastSize) {
          const newLogs = data.logs.slice(lastSize)
          callback({ type: 'logs', data: newLogs })
          lastSize = data.logs.length
        }

        // If run is done, send final update and stop streaming
        if (['completed', 'failed', 'error'].includes(data.status)) {
          callback({ type: 'status', data: data.status })
          callback({ type: 'end', data: data })
          clearInterval(streamInterval)
        }
      }
    } catch (e) {
      console.error('Stream error:', e)
      callback({ type: 'error', data: e.message })
      clearInterval(streamInterval)
    }
  }, 500)

  // Return cleanup function
  return () => clearInterval(streamInterval)
}
