import express from 'express';
import bcryptjs from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { body, validationResult } from 'express-validator';
import nodemailer from 'nodemailer';
import db from '../db/index.js';
import mongo from '../db/mongo.js';

const router = express.Router();

// ==================== UTILITIES ====================

// Generate JWT Token
const generateToken = (userId, type = 'access') => {
  const secret = type === 'access' ? process.env.JWT_SECRET : process.env.JWT_REFRESH_SECRET || 'refresh_secret';
  const expiresIn = type === 'access' ? process.env.JWT_EXPIRE || '7d' : '30d';
  
  return jwt.sign(
    { userId, type },
    secret,
    { expiresIn }
  );
};

// Hash Password
const hashPassword = async (password) => {
  return await bcryptjs.hash(password, 12);
};

// Compare Password
const comparePassword = async (password, hashedPassword) => {
  return await bcryptjs.compare(password, hashedPassword);
};

// Generate OTP
const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

// Send Email
const sendEmail = async (to, subject, text, html) => {
  try {
    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      secure: true,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });

    await transporter.sendMail({
      from: process.env.SMTP_USER,
      to,
      subject,
      text,
      html
    });

    return true;
  } catch (error) {
    console.error('Email sending failed:', error);
    return false;
  }
};

// ==================== ROUTES ====================

/**
 * @route   POST /api/v1/auth/register
 * @desc    Register a new user
 * @access  Public
 */
router.post('/register', [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }).withMessage('Password must be at least 8 characters'),
  body('name').trim().notEmpty(),
  body('userType').isIn(['business', 'student', 'startup', 'freelancer'])
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ success: false, errors: errors.array() });
    }

    const { email, password, name, userType } = req.body;

    // Check if user already exists (try MongoDB if configured, always fallback to file DB)
    let existingUser = null;
    const useMongo = process.env.MONGODB_URI && !process.env.MONGODB_URI.includes('<user>');
    if (useMongo) {
      existingUser = await mongo.findUserByEmail(email);
    }
    if (!existingUser) {
      await db.read();
      existingUser = db.data.users.find(u => u.email === email);
    }
    if (existingUser) {
      return res.status(409).json({ success: false, message: 'User already exists' });
    }

    // Hash password
    const hashedPassword = await hashPassword(password);

    // Generate OTP
    const otp = generateOTP();

    // Create user object and persist
    const user = {
      id: Date.now().toString(),
      email,
      password: hashedPassword,
      name,
      userType,
      otpVerified: false,
      createdAt: new Date()
    };

    if (useMongo) {
      // Try to persist to Mongo
      const mongoUser = await mongo.createUser({ ...user, createdAt: new Date(), otpVerified: false });
      if (!mongoUser) {
        // MongoDB failed, fall back to file DB
        db.data.users.push(user);
        db.data.otps.push({ email, otp, expiresAt: Date.now() + 10 * 60 * 1000 });
        await db.write();
      } else {
        // MongoDB succeeded, store OTP there
        await mongo.addOtp({ email, otp, expiresAt: Date.now() + 10 * 60 * 1000 });
      }
    } else {
      // Use file DB directly
      db.data.users.push(user);
      // Store OTP with expiry (10 minutes)
      db.data.otps.push({ email, otp, expiresAt: Date.now() + 10 * 60 * 1000 });
      await db.write();
    }

    // Send OTP email (best-effort)
    await sendEmail(
      email,
      'AI Builder - Email Verification OTP',
      `Your OTP is: ${otp}`,
      `<h2>Welcome to AI Builder!</h2><p>Your verification OTP is: <strong>${otp}</strong></p>`
    );

    res.status(201).json({
      success: true,
      message: 'User registered. Please verify your email.',
      data: {
        userId: user.id,
        email: user.email,
        name: user.name,
        userType: user.userType
      }
    });

  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ success: false, message: 'Registration failed' });
  }
});

/**
 * @route   POST /api/v1/auth/verify-email
 * @desc    Verify user email with OTP
 * @access  Public
 */
router.post('/verify-email', [
  body('email').isEmail(),
  body('otp').isLength({ min: 6, max: 6 })
], async (req, res) => {
  try {
    const { email, otp } = req.body;
    const useMongo = process.env.MONGODB_URI && !process.env.MONGODB_URI.includes('<user>');

    // Verify OTP: try MongoDB first, then file DB
    let otpRecord = null;
    let user = null;
    
    if (useMongo) {
      otpRecord = await mongo.findOtp(email, otp);
      user = await mongo.findUserByEmail(email);
    }
    
    if (!otpRecord) {
      // Fall back to file DB
      await db.read();
      const otpRecordIndex = db.data.otps.findIndex(o => o.email === email && o.otp === otp);
      otpRecord = otpRecordIndex !== -1 ? db.data.otps[otpRecordIndex] : null;
      user = db.data.users.find(u => u.email === email);
      
      if (!otpRecord || otpRecord.expiresAt < Date.now()) {
        return res.status(400).json({ success: false, message: 'Invalid or expired OTP' });
      }
      
      // Mark user as verified in file DB
      if (user) user.otpVerified = true;
      if (otpRecordIndex !== -1) db.data.otps.splice(otpRecordIndex, 1);
      await db.write();
    } else {
      // Verify in MongoDB
      if (!otpRecord || otpRecord.expiresAt < Date.now()) {
        return res.status(400).json({ success: false, message: 'Invalid or expired OTP' });
      }
      await mongo.markUserVerified(email);
      await mongo.removeOtp(email, otp);
    }

    // Generate tokens
    const accessToken = generateToken(user ? user.id : 'mock-user-id', 'access');
    const refreshToken = generateToken(user ? user.id : 'mock-user-id', 'refresh');

    res.json({
      success: true,
      message: 'Email verified successfully',
      data: {
        accessToken,
        refreshToken,
        user: {
          email,
          verified: true
        }
      }
    });

  } catch (error) {
    console.error('Verification error:', error);
    res.status(500).json({ success: false, message: 'Verification failed' });
  }
});

/**
 * @route   POST /api/v1/auth/login
 * @desc    Login user
 * @access  Public
 */
router.post('/login', [
  body('email').isEmail(),
  body('password').notEmpty()
], async (req, res) => {
  try {
    const { email, password } = req.body;
    const useMongo = process.env.MONGODB_URI && !process.env.MONGODB_URI.includes('<user>');
    
    // Find user: try MongoDB first, then file DB
    let user = null;
    if (useMongo) {
      user = await mongo.findUserByEmail(email);
    }
    if (!user) {
      await db.read();
      user = db.data.users.find(u => u.email === email);
    }
    if (!user) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    // Compare password
    const validPassword = await comparePassword(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    // Generate tokens
    const accessToken = generateToken(user.id, 'access');
    const refreshToken = generateToken(user.id, 'refresh');

    res.json({
      success: true,
      message: 'Login successful',
      data: {
        accessToken,
        refreshToken,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          userType: user.userType
        }
      }
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ success: false, message: 'Login failed' });
  }
});

/**
 * @route   POST /api/v1/auth/refresh-token
 * @desc    Refresh access token
 * @access  Public
 */
router.post('/refresh-token', async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(400).json({ success: false, message: 'Refresh token required' });
    }

    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET || 'refresh_secret');

    // Generate new access token
    const newAccessToken = generateToken(decoded.userId, 'access');

    res.json({
      success: true,
      data: { accessToken: newAccessToken }
    });

  } catch (error) {
    res.status(401).json({ success: false, message: 'Invalid refresh token' });
  }
});

/**
 * @route   POST /api/v1/auth/logout
 * @desc    Logout user
 * @access  Private
 */
router.post('/logout', (req, res) => {
  try {
    // Clear tokens (client-side) and session (server-side if needed)
    res.json({
      success: true,
      message: 'Logout successful'
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Logout failed' });
  }
});

/**
 * @route   POST /api/v1/auth/resend-otp
 * @desc    Resend OTP for email verification
 * @access  Public
 */
router.post('/resend-otp', [
  body('email').isEmail()
], async (req, res) => {
  try {
    const { email } = req.body;

    const otp = generateOTP();

    await sendEmail(
      email,
      'AI Builder - OTP Resent',
      `Your new OTP is: ${otp}`,
      `<h2>New OTP</h2><p>Your verification OTP is: <strong>${otp}</strong></p><p>Valid for 10 minutes</p>`
    );

    res.json({
      success: true,
      message: 'OTP sent successfully'
    });

  } catch (error) {
    console.error('Resend OTP error:', error);
    res.status(500).json({ success: false, message: 'Failed to resend OTP' });
  }
});

/**
 * @route   POST /api/v1/auth/forgot-password
 * @desc    Request password reset
 * @access  Public
 */
router.post('/forgot-password', [
  body('email').isEmail()
], async (req, res) => {
  try {
    const { email } = req.body;

    // Generate reset token
    const resetToken = generateToken('mock-user-id', 'reset');

    // Send reset email
    await sendEmail(
      email,
      'AI Builder - Password Reset',
      `Click here to reset: http://localhost:3000/reset-password?token=${resetToken}`,
      `<h2>Password Reset</h2><p><a href="http://localhost:3000/reset-password?token=${resetToken}">Click here to reset your password</a></p>`
    );

    res.json({
      success: true,
      message: 'Password reset link sent to email'
    });

  } catch (error) {
    res.status(500).json({ success: false, message: 'Failed to send reset email' });
  }
});

/**
 * @route   POST /api/v1/auth/reset-password
 * @desc    Reset password with token
 * @access  Public
 */
router.post('/reset-password', [
  body('token').notEmpty(),
  body('newPassword').isLength({ min: 8 })
], async (req, res) => {
  try {
    const { token, newPassword } = req.body;

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Hash new password
    const hashedPassword = await hashPassword(newPassword);

    // Update user password (mock - replace with DB update)
    // await User.updateOne({ id: decoded.userId }, { password: hashedPassword });

    res.json({
      success: true,
      message: 'Password reset successfully'
    });

  } catch (error) {
    res.status(400).json({ success: false, message: 'Invalid or expired token' });
  }
});


/**
 * @route   GET /api/v1
 * @desc    API status check
 * @access  Public
 */
router.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'AI Builder Platform - Backend API',
    data: {
      server: {
        port: process.env.PORT || 5000,
        environment: process.env.NODE_ENV || 'development',
        url: `http://localhost:${process.env.PORT || 5000}`
      },
      status: 'Ready to accept requests'
    }
  });
});
export default router;
